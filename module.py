import numpy as np
import matplotlib.pyplot as plt
import os
from sklearn.decomposition import PCA
from matplotlib.lines import Line2D

# import the essential packages: numpy as np, matplotlib.pyplot as plt, sklearn.decomposition.PCA as pca
# File container overall is dictionary. The naming format is eccentricity_videoclip_channel. For example: ecc03_2_y1x.
# Please refer bashload function for the naming regulation.
####################### Unit for manual data checking ##########################
class Datahandle:
    def __init__(self, filename):
        # path of data
        self.filename = filename
    def read(self):
        if self.filename[-3:] != 'txt':
            print('File extension is not *.txt')
        else:
            return np.loadtxt(self.filename)
def testplot(x,y):
    #   require import matplotlib.pyplot as plt
    #   require
    fig = plt.figure()
    ax = fig.add_subplot(1,1,1)
    if type(x) == str:
        x = Datahandle(x)
    if type(y) == str:
        y = Datahandle(y)
    ax.plot(x.read(), y.read(), '+')



    # testplot(x,y)

####################### Main process block ####################################
# Batch unit process
def bashload(main_path):

    # Please arrange your data in the following structure:
    #
    #   -main_path
    #       -2019xxxx_eccxx(the folder format should be time_ecc00)
    #           -video data set(pure number, etc 1,2,3...)
    #               -y1x.txt (y1:yoyo1, y3:yoyo3 etc). TODO: Implement file format modification unit.
    main_path = main_path
    tot_file = {}
    if os.path.exists(main_path):
        os.chdir(main_path)
    else:
        print("No such directory, please check.")
        return ""
    subfolder = os.listdir(main_path)
    for i in subfolder:
        subpath = main_path+'/'+i
        os.chdir(subpath)
        subsubfolder = os.listdir()
        for j in subsubfolder:
            if j[-3:]=="txt":
                continue
            else:
                temp = subpath+'/'+j
                os.chdir(temp)
                prefix = i+'_'+j
                filename = os.listdir()
            for k in filename:
                fname_temp = prefix + '_'+ k[:3]
                # print(fname_temp.split('_'))
                fname_temp = fname_temp.split('_')[1]+ '_'+ fname_temp.split('_')[2]+'_'+ fname_temp.split('_')[3]
                # print(fname_temp)
                fpath_temp = temp + '/'+ k
                # print(fpath_temp)
                tot_file[fname_temp] = np.loadtxt(fpath_temp)
                # exec('print('+fname_temp+')')
    # print(tot_file["ecc03_1y1x"])
    return tot_file
def bashvector(tot_file):
    # Calculate the vector separation for each video
    # tot_file: dictionary of data. Generated by bashload function.
    tot_vector = {}
    temp = ""
    for i in tot_file:
        prefix = i.split('_')[0]+'_'+i.split('_')[1]
        if prefix != temp:
            temp = prefix
            tot_vector[prefix+'_delx'] = tot_file[prefix+'_y3x']-tot_file[prefix+'_y1x']
            tot_vector[prefix+'_dely'] = tot_file[prefix+'_y3y']-tot_file[prefix+'_y1y']
        else:
            continue
    return tot_vector
def bashoverlay(tot_vector):
    # over lay videos sharing the same cavity shape
    # tot_vector: delta x,y dictionary. Generated by bashvector function.
    temp = ""
    tot_vec_overlay = {}
    for i in tot_vector:
        prefix = i.split('_')[0]
        if prefix != temp:
            temp = prefix
            tot_vec_overlay[temp + '_delx'] = np.array([])
            tot_vec_overlay[temp + '_dely'] = np.array([])

    for i in tot_vector:
        prefix = i.split('_')[0]
        # print(i[-1])
        if i[-1] =='x':
            tot_vec_overlay[prefix + '_delx'] = np.append(tot_vec_overlay[prefix + '_delx'], tot_vector.get(i))
        else:
            tot_vec_overlay[prefix + '_dely'] = np.append(tot_vec_overlay[prefix + '_dely'], tot_vector.get(i))
    return tot_vec_overlay
def bashfree(tot_vector, type):
    # Please refer to 'Entropic Segregation of Polymers under Confinement' Pg107, Eq. 5.3.1. Author: Vorgelegt von Elena Minina.
    # 1.PCA alignment of the eclipse(require sklearn.decomposition.PCA module)
    # 2.Define the x-axis separation by coding the data in pca's principle axis
    # 3.Calculate the landscape
    # type------"v" means input is tot_vector from bashvector, "o" means input is totoverlay from bashoverlay. TODO: Automatically distinguish the file type by its name format.
    #################################################################

    tot_free ={}
    sep_projection = {}
    temp = ''
    n_components = 2
    pca = PCA(n_components=n_components)
    for i in tot_vector:
        if type == "v":
            prefix = i.split('_')[0] + '_' + i.split('_')[1]
        elif type == "o":
            prefix = i.split('_')[0]
        else:
            print("Please insert the type of input")
            break
        if prefix != temp:
            temp = prefix
            xtemp = tot_vector[prefix+'_delx']
            xtemp = xtemp - np.mean(xtemp)
            ytemp = tot_vector[prefix+'_dely']
            ytemp = ytemp - np.mean(ytemp)
            xtrain = np.transpose(np.array([xtemp, ytemp]))
            # x_sep is a 2*n array where row is principle axis, column is the coding.
            x_sep = np.transpose(pca.fit_transform(xtrain))
            ############## quick and dirty/ abs negative part ###################
            # x_sep[0, :] = abs(x_sep[0,:])
            ##########################
            sep_projection[temp + '_sep'] = x_sep

            # free energy
            xhist, xbin = np.histogram(x_sep[0, :], bins = 30)
            xhist_short, xbin_short = np.histogram(x_sep[1, :], bins=30)
            index = np.argwhere(xbin>=0)
            index_short = np.argwhere(xbin_short>=0)
            free = -np.log(xhist/len(x_sep[0, :])) + np.log(xhist[index[0, 0]]/len(x_sep[0, :]))
            free_short = -np.log(xhist_short/len(x_sep[1, :])) + np.log(xhist_short[index_short[0, 0]]/len(x_sep[1, :]))
            tot_free[temp + '_F'] = free
            tot_free[temp+'_Fs'] = free_short
            tot_free[temp + '_bins'] = xbin[0:-1]
            tot_free[temp + '_binss'] = xbin_short[0:-1]
            ###################### Maintaining code ###############
            # cov = np.cov(xtemp, ytemp)
            # eig, vec = np.linalg.eigh(cov)
            # tot_ortaxis[temp] = vec
            # # Axis rotation
            # if np.abs(eig[0]) > np.abs(eig[1]):
            #     xrot = vec[:,0]
            # else:
            #     xrot = vec[:,1]
            # theta = np.arctan2(xrot[0], xrot[1])
            # transmatrix[0, 0] = np.cos(theta)
            # transmatrix[0, 1] = -np.sin(theta)
            # transmatrix[1, 0] = np.sin(theta)
            # transmatrix[1, 1] = np.cos(theta)
            # xtrain = np.array([xtemp,ytemp])
            # plt.plot(xtrain[0, :], xtrain[1, :])
            # xtrain_rotated = np.dot(transmatrix, xtrain)
            # xdensity = xtrain_rotated[0,:]
            # # plt.plot(xtrain_rotated[0,:], xtrain_rotated[1,:])
            #plt.show()
            #########################################################
    return tot_free, sep_projection
def bashfreeplt(tot_free):
    # tot_free--
    # Here the input has to come from bashfree with type'o'. Otherwise there will be too many lines in the graph. Too disturbing.
    fig = plt.figure()
    ax = fig.add_subplot(1,1,1)
    temp = ''
    legend = []
    for i in tot_free:
        prefix = i.split('_')[0]
        if prefix != temp:
            temp = prefix
            legend.append(temp)
            legend.append(temp+'inv')
            ax.plot(tot_free[prefix+'_bins'], tot_free[prefix+'_F'])
            if prefix != 'ecc0':
                ax.plot(tot_free[prefix + '_binss'], tot_free[prefix + '_Fs'])
    ax.legend(legend)
    return ax
def bashpos(tot_vector):
    # mapping the data from negative axis to positive. Assuming the symmetric.
    for i in tot_vector:
        if i.split('_')[-1] == 'delx':
            tot_vector[i] = abs(tot_vector[i])
    return tot_vector

################################################################################

def main_ll():
    ################### loading data ######################
    main_path = 'D:/McGillResearch/2019Manuscript_Analysis/Analysis/groupmeeting_dataset'
    tot_file = bashload(main_path)
    print('There is '+str(len(tot_file))+' files in total.')

    ################### delta x,y calculation #############
    tot_vector = bashvector(tot_file)
    # plt.plot(tot_vector.get('ecc0_1_delx'), tot_vector.get('ecc0_1_dely'), "+")

    ################### over lay videos sharing the same cavity shape #######
    tot_vec_overlay = bashoverlay(tot_vector)
    # plt.plot(tot_vec_overlay['ecc06_delx'],tot_vec_overlay['ecc06_dely'],'+')
    # plt.plot(tot_vec_overlay['ecc03_delx'], tot_vec_overlay['ecc03_dely'], '+')
    # plt.legend(['6','3'])
    ################### calculate the free energy landscape #########
    tot_free, sep = bashfree(tot_vec_overlay, type = "o")
    # plt.plot(tot_free['ecc095_bins'], tot_free['ecc095_F'])

    ################### plot free energy landscape ################
    ax = bashfreeplt(tot_free)
    unit = 0.16 #160um/pixel
    ax.set_xlim([0,14])
    xticks = ax.get_xticks()
    cov_xticks = xticks * unit
    ax.set_xticklabels(cov_xticks)

    ax.set_xlabel(r'X-separation($/mu$m)', fontsize = 15)
    ax.set_ylabel(r'Free energy($/mathrm{k_B}$T)', fontsize = 15)

    ax.tick_params(axis ='both', labelsize=13)

    ################### plot order parameter change #################
    fig2 = plt.figure()
    ax2 = fig2.add_subplot(1, 1, 1)
    temp = 1/np.array([np.sqrt(1-0.995**2), np.sqrt(1-0.95**2), np.sqrt(1-0.9**2), np.sqrt(1-0.6**2), 1, 1/np.sqrt(1-0.6**2), 1/np.sqrt(1-0.9**2), 1/np.sqrt(1-0.95**2), 1/np.sqrt(1-0.995**2)])
    order = np.array([0,0,0,0,0,0.64,0.96,1.05,1.28])
    ax2.plot(temp, order, 'o')
    ax2.set_xlim([0,4])
    ax2.set_xlabel('Aspect ratio(b/a)', fontsize = 15)
    ax2.set_ylabel(r'X-separation($/mu$ m)', fontsize = 15)
    ax2.tick_params(axis = 'both', labelsize=13)
    ###################################
    plt.show()
    print(1)

def main_lp():
    ################### loading data ######################
    main_path = 'D:/McGillResearch/2019Manuscript_Analysis/Analysis/groupmeeting_lp'
    tot_file = bashload(main_path)
    print('There is ' + str(len(tot_file)) + ' files in total.')



    fig = plt.figure()
    ax = fig.add_subplot(1,1,1)
    ax.plot(tot_file['ecc09_1_y3x'],tot_file['ecc09_1_y3y'],'+')
    xtick = ax.get_xticks()
    ytick = ax.get_yticks()
    unit = 0.16
    ax.set_xticklabels(xtick * unit)
    ax.set_yticklabels(ytick * unit)
    ax.set_xlabel(r'X position($\mu$m)', fontsize = 15)
    ax.set_ylabel(r'Y position($\mu$m)', fontsize = 15)
    ax.tick_params(labelsize = 13)
    ax.set_title(r'$\lambda$ DNA position distribution')
    ax.legend(['ecc09'])

    fig2 = plt.figure()
    ax2 = fig2.add_subplot(1, 1, 1)
    ax2.plot(tot_file['ecc09_1_y1x'], tot_file['ecc09_1_y1y'], '+')
    xtick = ax2.get_xticks()
    ytick = ax2.get_yticks()
    unit = 0.16
    ax2.set_xticklabels(xtick * unit)
    ax2.set_yticklabels(ytick * unit)
    ax2.set_xlabel(r'X position($\mu$m)', fontsize=15)
    ax2.set_ylabel(r'Y position($\mu$m)', fontsize=15)
    ax2.tick_params(labelsize=13)
    ax2.set_title('Plasmid position distribution')
    ax2.legend(['ecc09'])
    # plt.plot(tot_file['ecc0_1_y1x'], tot_file['ecc0_1_y1y'], 'o')
    ################### delta x,y calculation #############
    tot_vector = bashvector(tot_file)
    # plt.plot(tot_vector.get('ecc0_1_delx'), tot_vector.get('ecc0_1_dely'), "+")

    plt.show()

def main_tp():
    main_path = 'D:/McGillResearch/2019Manuscript_Analysis/Analysis/groupmeeting_tp'
    tot_file = bashload(main_path)
    print('There is ' + str(len(tot_file)) + ' files in total.')

    fig = plt.figure()
    ax = fig.add_subplot(1, 1, 1)
    line = ax.plot(tot_file['ecc03_1_y3x'], tot_file['ecc03_1_y3y'], '+')
    ax.plot(tot_file['ecc03_2_y3x'], tot_file['ecc03_2_y3y'], '+', color = Line2D.get_color(line[0]))
    xtick = ax.get_xticks()
    ytick = ax.get_yticks()
    unit = 0.16
    # ax.set_xticklabels(xtick * unit)
    # ax.set_yticklabels(ytick * unit)
    ax.set_xlabel(r'X position(pixel)', fontsize=15)
    ax.set_ylabel(r'Y position(pixel)', fontsize=15)
    ax.tick_params(labelsize=13)
    ax.set_title('T4 DNA position distribution')
    ax.legend(['ecc03'])
    ax.set_ylim([3, 18])
    ax.set_xlim([3, 18])
    fig2 = plt.figure()
    ax2 = fig2.add_subplot(1, 1, 1)
    line = ax2.plot(tot_file['ecc03_1_y1x'], tot_file['ecc03_1_y1y'], '+')
    ax2.plot(tot_file['ecc03_2_y1x'], 20 - tot_file['ecc03_2_y1y'], '+', color = Line2D.get_color(line[0]))
    xtick = ax2.get_xticks()
    ytick = ax2.get_yticks()
    unit = 0.16
    # ax2.set_xticklabels(xtick * unit)
    # ax2.set_yticklabels(ytick * unit)
    ax2.set_xlabel(r'X position(pixel)', fontsize=15)
    ax2.set_ylabel(r'Y position(pixel)', fontsize=15)
    ax2.tick_params(labelsize=13)
    ax2.set_title('Plasmid position distribution')
    ax2.legend(['ecc03'])
    # plt.plot(tot_file['ecc0_1_y1x'], tot_file['ecc0_1_y1y'], 'o')
    ################### delta x,y calculation #############
    tot_vector = bashvector(tot_file)
    # plt.plot(tot_vector.get('ecc0_1_delx'), tot_vector.get('ecc0_1_dely'), "+")
    ax2.set_ylim([3, 18])
    ax2.set_xlim([3, 18])
    plt.show()


###############################################
if __name__=="__main__":
    main_tp()
# plt.show()